#!/usr/bin/env python
'''
parse a MAVLink protocol XML file and generate a ruby iumplementation

Copyright Andrew Tridgell 2011
Released under GNU GPL version 3 or later
'''

import sys, textwrap, os
import mavparse, mavtemplate

t = mavtemplate.MAVTemplate()

def generate_preamble(outf, msgs, args, xml):
    print("Generating preamble")
    t.write(outf, """
# MAVLink protocol implementation (auto-generated by mavgen.py)
# Generated from: ${FILELIST}
# Note: this file has been auto-generated. DO NOT EDIT

require 'time'
require 'json'

WIRE_PROTOCOL_VERSION = "${WIRE_PROTOCOL_VERSION}"


# some base types from mavlink_types.h
MAVLINK_TYPE_CHAR     = 0
MAVLINK_TYPE_UINT8_T  = 1
MAVLINK_TYPE_INT8_T   = 2
MAVLINK_TYPE_UINT16_T = 3
MAVLINK_TYPE_INT16_T  = 4
MAVLINK_TYPE_UINT32_T = 5
MAVLINK_TYPE_INT32_T  = 6
MAVLINK_TYPE_UINT64_T = 7
MAVLINK_TYPE_INT64_T  = 8
MAVLINK_TYPE_FLOAT    = 9
MAVLINK_TYPE_DOUBLE   = 10

class X25CRC
    # x25 CRC - based on checksum.h from mavlink library
    attr_accessor :crc

    def initialize(buf = '')
        @crc = 0xffff
        accumulate(buf)
    end

    def accumulate(buf):
        # add in some more bytes
        bytes = buf.class == Array ? buf : buf.bytes.to_a
        accum = @crc
        bytes.each do |b|
            tmp = b ^ (accum & 0xff)
            tmp = (tmp ^ (tmp << 4)) & 0xFF
            accum = (accum >> 8) ^ (tmp << 8) ^ (tmp << 3) ^ (tmp >> 4)
            accum = accum & 0xFFFF
        end
        @crc = accum
    end
end


class MAVLink_header
    # MAVLink message header
    attr_accessor :mlen, :seq, :srcSystem, :srcComponent, :msgId

    def initialize(msgId, mlen = 0, seq = 0, srcSystem = 0, srcComponent = 0):
        @mlen = mlen
        @seq = seq
        @srcSystem = srcSystem
        @srcComponent = srcComponent
        @msgId = msgId
    end

    def pack
        [${PROTOCOL_MARKER}, @mlen, @seq, @srcSystem, @srcComponent, @msgId].pack('CCCCCC')
    end
end

class MAVLink_message
    # base MAVLink message class
    attr_accessor :header, :payload, :msgbuf, :crc, :fieldnames, :type

    def initialize(msgId, name)
        @header = MAVLink_header(msgId)
        @payload = nil
        @msgbuf = nil
        @crc = nil
        @fieldnames = []
        @type = name
    end

    def msgbuf
        @msgbuf.class == String ? @msgbuf : @msgbuf.to_s
    end

    def msgId
        @header.msgId
    end

    def srcSystem
        @header.srcSystem
    end

    def srcComponent
        @header.srcComponent
    end

    def seq
        @header.seq
    end

    #def __str__(self)
    #    ret = '%s {' % self._type
    #    for a in self._fieldnames
    #        v = getattr(self, a)
    #        ret += '%s : %s, ' % (a, v)
    #    end
    #    ret = ret[0:-2] + '}'
    #    return ret            
    #end

    #def to_dict(self)
    #    d = dict({})
    #    d['mavpackettype'] = self._type
    #    for a in self._fieldnames:
    #      d[a] = getattr(self, a)
    #    end
    #    return d
    #end

    #def to_json(self)
    #    return json.dumps(self.to_dict())
    #end

    def pack(mav, crc_extra, payload)
        @payload = payload
        @header  = MAVLink_header(@header.msgId, payload.length, mav.seq, mav.srcSystem, mav.srcComponent)
        @msgbuf = @header.pack + @payload
        crc = X25CRC(@msgbuf[1,@msgbuf.length])
        crc.accumulate(crc_extra.chr) if crc_extra # using CRC extra
        @crc = crc.crc
        @msgbuf += [@crc].pack('S<')
        return @msgbuf
    end
end

""", {'FILELIST' : ",".join(args),
      'PROTOCOL_MARKER' : xml.protocol_marker,
      'crc_extra' : xml.crc_extra,
      'WIRE_PROTOCOL_VERSION' : xml.wire_protocol_version })


def generate_enums(outf, enums):
    print("Generating enums")
    outf.write("\n# enums\n")
    wrapper = textwrap.TextWrapper(initial_indent="", subsequent_indent="                        # ")
    for e in enums:
        outf.write("\n# %s\n" % e.name)
        for entry in e.entry:
            outf.write("%s = %u # %s\n" % (entry.name, entry.value, wrapper.fill(entry.description)))

def generate_message_ids(outf, msgs):
    print("Generating message IDs")
    outf.write("\n# message IDs\n")
    outf.write("MAVLINK_MSG_ID_BAD_DATA = -1\n")
    for m in msgs:
        outf.write("MAVLINK_MSG_ID_%s = %u\n" % (m.name.upper(), m.id))

def generate_classes(outf, msgs):
    print("Generating class definitions")
    wrapper = textwrap.TextWrapper()
    wrapper.width = 999
    for m in msgs:
        attrs = 'attr_accessor '
        for f in m.fields:
            attrs += ":%s, " % (f.name)
        attrs = attrs[:-2] + "\n"
        outf.write("""
class MAVLink_%s_message < MAVLink_message
    # %s
    %s
    def initialize(""" % (m.name.lower(), wrapper.fill(m.description.strip()),attrs))
        if len(m.fields) != 0:
                outf.write(", ".join(m.fieldnames))
        outf.write(")\n")
        outf.write("        super(MAVLINK_MSG_ID_%s, '%s')\n" % (m.name.upper(), m.name.upper()))
        if len(m.fieldnames) != 0:
                outf.write("        @fieldnames = ['%s']\n" % "', '".join(m.fieldnames))
        for f in m.fields:
                outf.write("        @%s = %s\n" % (f.name, f.name))
        outf.write("    end\n")
        fields = ''
        if len(m.fields) != 0:
                fields = "@" + ", @".join(m.ordered_fieldnames)
        outf.write("""
    def pack(mav)
        return super.pack(mav, %u, [%s].pack('%s'))\n""" % (m.crc_extra, fields, m.fmtstr))
        outf.write("    end\n")
        outf.write("end\n")


def mavfmt(field):
    '''work out the struct format for a type'''
    map = {
        'float'    : 'f',
        'double'   : 'd',
        'char'     : 'a',
        'int8_t'   : 'c',
        'uint8_t'  : 'C',
        'uint8_t_mavlink_version'  : 'C',
        'int16_t'  : 's',
        'uint16_t' : 'S',
        'int32_t'  : 'l',
        'uint32_t' : 'L',
        'int64_t'  : 'q',
        'uint64_t' : 'Q',
        }

    if field.array_length:
        if field.type in ['char', 'int8_t', 'uint8_t']:
            return 'a'+str(field.array_length)
        return str(field.array_length)+map[field.type]
    return map[field.type]

def generate_mavlink_class(outf, msgs, xml):
    print("Generating MAVLink class")

    outf.write("\n\nmavlink_map = {\n");
    for m in msgs:
        outf.write("        MAVLINK_MSG_ID_%s => { :format => '%s', :type => MAVLink_%s_message, :order_map => %s, :crc_extra => %u },\n" % (
            m.name.upper(), m.fmtstr, m.name.lower(), m.order_map, m.crc_extra))
    outf.write("}\n\n")
    
    t.write(outf, """
class MAVError < Exception
    # MAVLink error class
    def __init__(self, msg):
        Exception.__init__(self, msg)
        self.message = msg
    end
end

class MAVString(str)
    # NUL terminated string
    def initialize(self, s)
        str.__init__(self)
    end
    def __str__(self)
        i = self.find(chr(0))
        if i == -1
         return self[:]
        end
        return self[0:i]
    end
end

class MAVLink_bad_data < MAVLink_message
    # a piece of bad data in a mavlink stream
    attr_accessor :fieldnames, :data, :reason, :msgbuf

    def initialize(data, reason)
        super(MAVLINK_MSG_ID_BAD_DATA, 'BAD_DATA')
        @fieldnames = ['data', 'reason']
        @data = data
        @reason = reason
        @msgbuf = data
    end

    def to_s
        # Override the __str__ function from MAVLink_messages because non-printable characters are common in to be the reason for this message to exist.'''
        out = ''
        @data.each do |i|
            out += i.class == String ? i.ord.to_s : i.to_s
        end
        return "#{@type}, {#{@type}, data: #{out}}"
    end
end
            
class MAVLink
    # MAVLink protocol handling class
    attr_accessor :seq, :file, :srcSystem, :srcComponent, :callback, :callback_args, :callback_kwargs, :send_callback, :send_callback_args, :send_callback_kwargs, :buf, :expected_length, :have_prefix_error, :robust_parsing, :protocol_marker, :little_endian, :crc_extra, :sort_fields, :total_packets_sent, :total_packets_received, :total_bytes_received, :total_receive_errors, :startup_time
    def initialize(file, srcSystem = 0, srcComponent = 0)
        @seq = 0
        @file = file
        @srcSystem = srcSystem
        @srcComponent = srcComponent
        @callback = nil
        @callback_args = nil
        @callback_kwargs = nil
        @send_callback = nil
        @send_callback_args = nil
        @send_callback_kwargs = nil
        @buf = array.array('B')
        @expected_length = 6
        @have_prefix_error = false
        @robust_parsing = false
        @protocol_marker = ${protocol_marker}
        @little_endian = ${little_endian}
        @crc_extra = ${crc_extra}
        @sort_fields = ${sort_fields}
        @total_packets_sent = 0
        @total_bytes_sent = 0
        @total_packets_received = 0
        @total_bytes_received = 0
        @total_receive_errors = 0
        @startup_time = time.time()
    end

#    def set_callback(callback, *args, **kwargs)
#        @callback = callback
#        @callback_args = args
#        @callback_kwargs = kwargs
#    end

#    def set_send_callback(callback, *args, **kwargs)
#        @send_callback = callback
#        @send_callback_args = args
#        @send_callback_kwargs = kwargs
#    end
            
    def send(mavmsg)
        # send a MAVLink message
        buf = mavmsg.pack(self)
        @file.write(buf)
        @seq = (@seq + 1) % 255
        @total_packets_sent += 1
        @total_bytes_sent += buf.length
#        @send_callback(mavmsg, *self.send_callback_args, **self.send_callback_kwargs) if @send_callback
    end

    def bytes_needed
        # return number of bytes needed for next parsing stage
        ret = @expected_length - @buf.length
        ret <= 0 ? return 1 : return ret
    end

    def parse_char(c)
        # input some data bytes, possibly returning a new message
        @buf = c.class == String ? @buf + c.bytes.to_a : @buf + c
        @total_bytes_received += c.length
        if @buf.length >= 1 and @buf[0] != ${protocol_marker}
            magic = @buf[0]
            @buf = @buf[1,@buf.length]
            if @robust_parsing
                m = MAVLink_bad_data(magic.chr, "Bad prefix")
#                @callback(m, *self.callback_args, **self.callback_kwargs) if @callback 
                @expected_length = 6
                @total_receive_errors += 1
                return m
            end
            return nil if @have_prefix_error
            @have_prefix_error = true
            @total_receive_errors += 1
            raise MAVError.new("invalid MAVLink prefix #{magic}") 
        end
        @have_prefix_error = false
        if @buf.length >= 2
            magic, @expected_length = @buf[0,2].pack("CC").unpack("CC")
            @expected_length += 8
        end
        if @expected_length >= 8 and @buf.length >= @expected_length
            mbuf = @buf[0,@expected_length]
            @buf = @buf[@expected_length,@buf.length]
            @expected_length = 6
            if @robust_parsing
                begin
                    m = decode(mbuf)
                    @total_packets_received += 1
                rescue MAVError => reason
                    m = MAVLink_bad_data.new(mbuf, reason.message)
                    @total_receive_errors += 1
                end
            else
                m = decode(mbuf)
                @total_packets_received += 1
            end
#            set_callback(m, *@callback_args, **@callback_kwargs) if @callback
            return m
        end
        return nil
    end

    def parse_buffer(s)
        # input some data bytes, possibly returning a list of new messages
        m = parse_char(s)
        return nil if m.nil?
        ret = [m]
        while true
            m = parse_char("")
            break if m.nil?
            ret.append(m)
        end
        return ret
    end

    def decode(msgbuf)
        # decode a buffer as a MAVLink message
        # decode the header
        begin
            magic, mlen, seq, srcSystem, srcComponent, msgId = msgbuf[0,6].pack('aCCCCC').unpack('aCCCCC')
        rescue Exception => ex
            raise MAVError("Unable to unpack MAVLink header: #{ex.inspect}")
        end
        raise MAVError.new("invalid MAVLink prefix #{magic}") if magic.ord != ${protocol_marker}
        raise MAVError.new("invalid MAVLink message length. Got #{msgbuf.length - 8} expected #{mlen}, msgId=#{msgId}") if mlen != msgbuf.length - 8
        raise MAVError.new("unknown MAVLink message ID #{msgId}") if !mavlink_map.has_key?(msgId)

        # decode the payload
        (fmt, type, order_map, crc_extra) = mavlink_map[msgId]

        # decode the checksum
        try:
            crc, = struct.unpack('<H', msgbuf[-2:])
        except struct.error as emsg:
            raise MAVError('Unable to unpack MAVLink CRC: %s' % emsg)
        end
        crc2 = X25CRC(msgbuf[1:-2])
        if ${crc_extra}: # using CRC extra 
            crc2.accumulate(chr(crc_extra))
        end
        if crc != crc2.crc:
            raise MAVError('invalid MAVLink CRC in msgID %u 0x%04x should be 0x%04x' % (msgId, crc, crc2.crc))
        end

        try:
            t = struct.unpack(fmt, msgbuf[6:-2])
        except struct.error as emsg:
            raise MAVError('Unable to unpack MAVLink payload type=%s fmt=%s payloadLength=%u: %s' % (
                type, fmt, len(msgbuf[6:-2]), emsg))
        end

        tlist = list(t)
        # handle sorted fields
        if ${sort_fields}:
            t = tlist[:]
            for i in range(0, len(tlist)):
                tlist[i] = t[order_map[i]]
            end
        end

        # terminate any strings
        for i in range(0, len(tlist)):
            if isinstance(tlist[i], str):
                tlist[i] = MAVString(tlist[i])
            end
        end
        t = tuple(tlist)
        # construct the message object
        try:
            m = type(*t)
        except Exception as emsg:
            raise MAVError('Unable to instantiate MAVLink message of type %s : %s' % (type, emsg))
        end
        m._msgbuf = msgbuf
        m._payload = msgbuf[6:-2]
        m._crc = crc
        m._header = MAVLink_header(msgId, mlen, seq, srcSystem, srcComponent)
        return m
    end\n
""", xml)

def generate_methods(outf, msgs):
    print("Generating methods")

    def field_descriptions(fields):
        ret = ""
        for f in fields:
            ret += "        #%-18s        : %s (%s)\n" % (f.name, f.description.strip(), f.type)
        return ret

    wrapper = textwrap.TextWrapper()
    wrapper.width = 999

    for m in msgs:
        comment = "#%s\n\n%s" % (wrapper.fill(m.description.strip()), field_descriptions(m.fields))

        selffieldnames = ''
        for f in m.fields:
            if f.omit_arg:
                selffieldnames += '%s=%s, ' % (f.name, f.const_value)
            else:
                selffieldnames += '%s, ' % f.name
        selffieldnames = selffieldnames[:-2]

        sub = {'NAMELOWER'      : m.name.lower(),
               'SELFFIELDNAMES' : selffieldnames,
               'COMMENT'        : comment,
               'FIELDNAMES'     : ", ".join(m.fieldnames)}

        t.write(outf, """
    def ${NAMELOWER}_encode(${SELFFIELDNAMES})
        ${COMMENT}
        msg = MAVLink_${NAMELOWER}_message(${FIELDNAMES})
        msg.pack
        return msg
    end
            
""", sub)

        t.write(outf, """
    def ${NAMELOWER}_send(${SELFFIELDNAMES})
        ${COMMENT}
        return send(${NAMELOWER}_encode(${FIELDNAMES}))
    end
            
""", sub)
    t.write(outf,"end\n")


def generate(basename, xml):
    '''generate complete ruby implemenation'''
    if basename.endswith('.rb'):
        filename = basename
    else:
        filename = basename + '.rb'

    msgs = []
    enums = []
    filelist = []
    for x in xml:
        msgs.extend(x.message)
        enums.extend(x.enum)
        filelist.append(os.path.basename(x.filename))

    for m in msgs:
        m.fmtstr = ''
        for f in m.ordered_fields:
            m.fmtstr += mavfmt(f)
        if xml[0].little_endian:
            m.fmtstr += '<'
        else:
            m.fmtstr += '>'
        m.order_map = [ 0 ] * len(m.fieldnames)
        for i in range(0, len(m.fieldnames)):
            m.order_map[i] = m.ordered_fieldnames.index(m.fieldnames[i])

    print("Generating %s" % filename)
    outf = open(filename, "w")
    generate_preamble(outf, msgs, filelist, xml[0])
    generate_enums(outf, enums)
    generate_message_ids(outf, msgs)
    generate_classes(outf, msgs)
    generate_mavlink_class(outf, msgs, xml[0])
    generate_methods(outf, msgs)
    outf.close()
    print("Generated %s OK" % filename)
